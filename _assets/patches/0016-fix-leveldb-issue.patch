diff --git a/eth/downloader/downloader.go b/eth/downloader/downloader.go
index edd0eb4d9..a1088bd23 100644
--- a/eth/downloader/downloader.go
+++ b/eth/downloader/downloader.go
@@ -152,6 +152,8 @@ type Downloader struct {
 	quitCh   chan struct{} // Quit channel to signal termination
 	quitLock sync.RWMutex  // Lock to prevent double closes
 
+	downloads sync.WaitGroup // Keeps track of the currently active downloads
+
 	// Testing hooks
 	syncInitHook     func(uint64, uint64)  // Method to call upon initiating a new sync run
 	bodyFetchHook    func([]*types.Header) // Method to call upon starting a block body fetch
@@ -415,7 +417,9 @@ func (d *Downloader) synchronise(id string, hash common.Hash, td *big.Int, mode
 // specified peer and head hash.
 func (d *Downloader) syncWithPeer(p *peerConnection, hash common.Hash, td *big.Int) (err error) {
 	d.mux.Post(StartEvent{})
+	d.downloads.Add(1)
 	defer func() {
+		d.downloads.Done()
 		// reset on error
 		if err != nil {
 			d.mux.Post(FailedEvent{err})
@@ -521,14 +525,22 @@ func (d *Downloader) syncWithPeer(p *peerConnection, hash common.Hash, td *big.I
 	} else if d.mode == FullSync {
 		fetchers = append(fetchers, d.processFullSyncContent)
 	}
-	return d.spawnSync(fetchers)
+	return d.spawnSync(errCanceled, fetchers)
 }
 
 // spawnSync runs d.process and all given fetcher functions to completion in
 // separate goroutines, returning the first error that appears.
-func (d *Downloader) spawnSync(fetchers []func() error) error {
+func (d *Downloader) spawnSync(errCancel error, fetchers []func() error) error {
+	d.cancelLock.Lock()
+	select {
+	case <-d.cancelCh:
+		d.cancelLock.Unlock()
+		return errCancel
+	default:
+	}
 	errc := make(chan error, len(fetchers))
 	d.cancelWg.Add(len(fetchers))
+	d.cancelLock.Unlock()
 	for _, fn := range fetchers {
 		fn := fn
 		go func() { defer d.cancelWg.Done(); errc <- fn() }()
@@ -592,6 +604,10 @@ func (d *Downloader) Terminate() {
 
 	// Cancel any pending download requests
 	d.Cancel()
+
+	// Wait, so external dependencies aren't destroyed
+	// until the download processing is done.
+	d.downloads.Wait()
 }
 
 // fetchHeight retrieves the head header of the remote peer to aid in estimating
