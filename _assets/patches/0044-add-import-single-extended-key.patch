diff --git a/accounts/keystore/key.go b/accounts/keystore/key.go
index 1873c8218..e57ff5022 100644
--- a/accounts/keystore/key.go
+++ b/accounts/keystore/key.go
@@ -47,9 +47,12 @@ type Key struct {
 	// we only store privkey as pubkey/address can be derived from it
 	// privkey in this struct is always in plaintext
 	PrivateKey *ecdsa.PrivateKey
-	// extended key is the root node for new hardened children i.e. sub-accounts
+	// ExtendedKey is the extended key of the PrivateKey itself, and it's used
+	// to derive child keys.
 	ExtendedKey *extkeys.ExtendedKey
-	// next index to be used for sub-account child derivation
+	// SubAccountIndex is DEPRECATED
+	// It was use in Status to keep track of the number of sub-account created
+	// before having multi-account support.
 	SubAccountIndex uint32
 }

diff --git a/accounts/keystore/keystore.go b/accounts/keystore/keystore.go
index 070177fb6..c1d8ca187 100644
--- a/accounts/keystore/keystore.go
+++ b/accounts/keystore/keystore.go
@@ -25,6 +25,7 @@ import (
 	crand "crypto/rand"
 	"errors"
 	"fmt"
+	"github.com/pborman/uuid"
 	"math/big"
 	"os"
 	"path/filepath"
@@ -461,14 +462,49 @@ func (ks *KeyStore) ImportECDSA(priv *ecdsa.PrivateKey, passphrase string) (acco
 	return ks.importKey(key, passphrase)
 }

+// ImportSingleExtendedKey imports an extended key setting it in both the PrivateKey and ExtendedKey fields
+// of the Key struct.
+// ImportExtendedKey is used in older version of Status where PrivateKey is set to be the BIP44 key at index 0,
+// and ExtendedKey is the extended key of the BIP44 key at index 1.
+func (ks *KeyStore) ImportSingleExtendedKey(extKey *extkeys.ExtendedKey, passphrase string) (accounts.Account, error) {
+	privateKeyECDSA := extKey.ToECDSA()
+	id := uuid.NewRandom()
+	key := &Key{
+		Id:          id,
+		Address:     crypto.PubkeyToAddress(privateKeyECDSA.PublicKey),
+		PrivateKey:  privateKeyECDSA,
+		ExtendedKey: extKey,
+	}
+
+	// if account is already imported, return cached version
+	if ks.cache.hasAddress(key.Address) {
+		a := accounts.Account{
+			Address: key.Address,
+		}
+		ks.cache.maybeReload()
+		ks.cache.mu.Lock()
+		a, err := ks.cache.find(a)
+		ks.cache.mu.Unlock()
+		if err != nil {
+			zeroKey(key.PrivateKey)
+			return a, err
+		}
+		return a, nil
+	}
+
+	return ks.importKey(key, passphrase)
+}
+
 // ImportExtendedKey stores ECDSA key (obtained from extended key) along with CKD#2 (root for sub-accounts)
 // If key file is not found, it is created. Key is encrypted with the given passphrase.
+// Deprecated: status-go is now using ImportSingleExtendedKey
 func (ks *KeyStore) ImportExtendedKey(extKey *extkeys.ExtendedKey, passphrase string) (accounts.Account, error) {
 	return ks.ImportExtendedKeyForPurpose(extkeys.KeyPurposeWallet, extKey, passphrase)
 }

 // ImportExtendedKeyForPurpose stores ECDSA key (obtained from extended key) along with CKD#2 (root for sub-accounts)
 // If key file is not found, it is created. Key is encrypted with the given passphrase.
+// Deprecated: status-go is now using ImportSingleExtendedKey
 func (ks *KeyStore) ImportExtendedKeyForPurpose(keyPurpose extkeys.KeyPurpose, extKey *extkeys.ExtendedKey, passphrase string) (accounts.Account, error) {
 	key, err := newKeyForPurposeFromExtendedKey(keyPurpose, extKey)
 	if err != nil {
